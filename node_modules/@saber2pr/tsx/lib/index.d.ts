declare type Props = {
    ref: TSX.Ref<any>;
    style: CSSStyle;
};
export declare function TSX(type: any, props: any, ...children: any[]): any;
export default TSX;
export declare type Suspense = {
    fallback: Node;
    children: Promise<Node>;
};
export declare const Suspense: ({ fallback, children }: Suspense) => Node;
export declare type LazyComponent = (props: Props) => Promise<{
    default: Node;
}>;
export declare const lazy: (lazyComponent: LazyComponent) => (props: Props) => Promise<Node>;
export declare const render: (component: Node, container: HTMLElement) => void;
declare global {
    namespace JSX {
        type IntrinsicElements = {
            [K in keyof HTMLElementTagNameMap]: TSX.IntrinsicAttributes<K>;
        };
        interface Element extends HTMLElement {
        }
        interface ElementChildrenAttribute {
            children: {};
        }
        export import Ref = TSX.Ref;
    }
}
export declare namespace TSX {
    export type RefCallback<T> = (instance: T) => void;
    export type RefObj<T> = {
        current: T;
    };
    export type Ref<T> = RefObj<T> | RefCallback<T>;
    interface TSXAttributes<T> {
        ref: Ref<T>;
        children: any;
    }
    type Attributes<K extends keyof HTMLElementTagNameMap> = Override<HTMLElementTagNameMap[K], "style", CSSStyle> & TSXAttributes<HTMLElementTagNameMap[K]>;
    export type IntrinsicAttributes<K extends keyof HTMLElementTagNameMap> = Partial<Attributes<K>>;
    export {};
}
export declare type CSSStyle = Partial<CSSStyleDeclaration>;
export declare type Override<T, K extends keyof T, V> = {
    [P in keyof T]: P extends K ? V : T[P];
};
export interface Microtask extends MutationCallback {
}
export declare function microtask(task: Microtask): void;
export declare function useEffect(effect: Function): void;
export declare function useRef<T>(current?: T): TSX.RefObj<T>;
